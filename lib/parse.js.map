{"version":3,"sources":["../src/parse.ts"],"names":["parseUrlPath","path","params","sourceFragments","paramsFragments","transforms","stopParsing","split","forEach","fragment","push","transform","keys","Map","Object","entries","filter","x","undefined","map","name","key","some","val","p","get","param","value","parse","validate","length","source","join","ext","target","substring","startsWith"],"mappings":";;;;;;;AAIA;;;;;;;;;;;;;;AAGO,SAASA,YAAT,CACLC,IADK,EAELC,MAFK,EAGS;AACd,MAAMC,eAAyB,GAAG,EAAlC;AACA,MAAMC,eAAyB,GAAG,EAAlC;AACA,MAAMC,UAAuB,GAAG,EAAhC;AACA,MAAIC,WAAW,GAAG,KAAlB;AAEAL,EAAAA,IAAI,CAACM,KAAL,CAAW,GAAX,EAAgBC,OAAhB,CAAwB,UAACC,QAAD,EAAc;AACpC,QAAIA,QAAQ,KAAK,EAAjB,EAAqB;AACnBN,MAAAA,eAAe,CAACO,IAAhB,CAAqBD,QAArB;AACA;AACD;;AAED,QAAIA,QAAQ,KAAK,GAAjB,EAAsB;AACpBH,MAAAA,WAAW,GAAG,IAAd;AACA;AACD;;AAED,QAAIA,WAAJ,EAAiB;AACfH,MAAAA,eAAe,CAACO,IAAhB,CAAqBD,QAArB;AACA;AACD;;AAED,QAAME,SAAoB,GAAG,EAA7B;AACA;;AACA,QAAMC,IAAI,GAAG,IAAIC,GAAJ,CACXC,MAAM,CAACC,OAAP,CAAeb,MAAf,EACGc,MADH,CACU,UAACC,CAAD;AAAA,aAAOA,CAAC,KAAKC,SAAb;AAAA,KADV,EAEGC,GAFH,CAEO;AAAA;AAAA,UAAEC,IAAF;AAAA,UAAQH,CAAR;;AAAA,aAAe,CAACA,CAAC,CAACI,GAAH,EAAQ,CAACD,IAAD,EAAOH,CAAP,CAAR,CAAf;AAAA,KAFP,CADW,CAAb,CAlBoC,CAwBpC;AACA;;AACAR,IAAAA,QAAQ,CAACF,KAAT,CAAe,GAAf,EAAoBe,IAApB,CAAyB,UAACL,CAAD,EAAO;AAAA,qBACXA,CAAC,CAACV,KAAF,CAAQ,GAAR,CADW;AAAA;AAAA,UACvBc,GADuB;AAAA,UAClBE,GADkB;;AAE9B,UAAMC,CAAC,GAAGD,GAAG,KAAKL,SAAR,GAAoBA,SAApB,GAAgCN,IAAI,CAACa,GAAL,CAASJ,GAAT,CAA1C;;AAEA,UAAIG,CAAJ,EAAO;AAAA,gCACiBA,CADjB;AAAA,YACEJ,IADF;AAAA,YACQM,MADR;AAEL;;;AACA,YAAMC,KAAU,GAAGD,MAAK,CAACE,KAAN,CAAYL,GAAZ,CAAnB;;AAEA,YAAII,KAAK,KAAKT,SAAV,IAAuBQ,MAAK,CAACG,QAAN,CAAeN,GAAf,MAAwB,KAAnD,EAA0D;AACxDZ,UAAAA,SAAS,CAACS,IAAD,CAAT,GAAqCO,KAArC;AACAf,UAAAA,IAAI,UAAJ,CAAYS,GAAZ;AACA,iBAAO,KAAP;AACD;AACF;;AAED,aAAO,IAAP;AACD,KAjBD;;AAmBA,QAAIP,MAAM,CAACF,IAAP,CAAYD,SAAZ,EAAuBmB,MAAvB,KAAkC,CAAtC,EAAyC;AACvC3B,MAAAA,eAAe,CAACO,IAAhB,CAAqBD,QAArB;;AAEA,UAAI,CAACH,WAAD,IAAgBD,UAAU,CAACyB,MAAX,GAAoB,CAAxC,EAA2C;AACzCxB,QAAAA,WAAW,GAAG,IAAd;AACD;AACF,KAND,MAMO;AACLF,MAAAA,eAAe,CAACM,IAAhB,CAAqBD,QAArB;AACAJ,MAAAA,UAAU,CAACK,IAAX,CAAgBC,SAAhB;AACD;AACF,GAvDD;AAyDA,MAAMoB,MAAM,GAAG5B,eAAe,CAAC6B,IAAhB,CAAqB,GAArB,CAAf;AACA,MAAMC,GAAG,GAAG,mBAAQF,MAAR,CAAZ;AACA,MAAMG,MAAM,GACV7B,UAAU,CAACyB,MAAX,GAAoB,CAApB,GACIC,MAAM,CAACI,SAAP,CAAiB,CAAjB,EAAoBJ,MAAM,CAACD,MAAP,GAAgBG,GAAG,CAACH,MAAxC,IACA,IADA,GAEA1B,eAAe,CAAC4B,IAAhB,CAAqB,IAArB,CAFA,GAGAC,GAJJ,GAKIf,SANN;AAQA,SAAO;AACLa,IAAAA,MAAM,EAAEA,MAAM,CAACK,UAAP,CAAkB,GAAlB,IAAyBL,MAAM,CAACI,SAAP,CAAiB,CAAjB,CAAzB,GAA+CJ,MADlD;AAELG,IAAAA,MAAM,EAAE,CAAAA,MAAM,SAAN,IAAAA,MAAM,WAAN,YAAAA,MAAM,CAAEE,UAAR,CAAmB,GAAnB,KAA0BF,MAAM,CAACC,SAAP,CAAiB,CAAjB,CAA1B,GAAgDD,MAFnD;AAGL7B,IAAAA,UAAU,EAAVA;AAHK,GAAP;AAKD","sourcesContent":["/**\n * Copyright (c) 2020-present Kriasoft | MIT License (https://git.io/JUgVL)\n */\n\nimport { extname } from \"path\";\nimport { Transform, Param, Params, ParsedOutput } from \"./types\";\n\nexport function parseUrlPath(\n  path: string,\n  params: Readonly<Params>,\n): ParsedOutput {\n  const sourceFragments: string[] = [];\n  const paramsFragments: string[] = [];\n  const transforms: Transform[] = [];\n  let stopParsing = false;\n\n  path.split(\"/\").forEach((fragment) => {\n    if (fragment === \"\") {\n      sourceFragments.push(fragment);\n      return;\n    }\n\n    if (fragment === \"_\") {\n      stopParsing = true;\n      return;\n    }\n\n    if (stopParsing) {\n      sourceFragments.push(fragment);\n      return;\n    }\n\n    const transform: Transform = {};\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    const keys = new Map<string, [key: string, param: Param<any>]>(\n      Object.entries(params as Required<Params>)\n        .filter((x) => x !== undefined)\n        .map(([name, x]) => [x.key, [name, x]]),\n    );\n\n    // Attempts to parse out parameters from the URL path fragment.\n    // E.g. \"w_80,h_16,c_fill\" => [\"w_80\", \"h_60\", \"c_fill\"]\n    fragment.split(\",\").some((x) => {\n      const [key, val] = x.split(\"_\");\n      const p = val === undefined ? undefined : keys.get(key);\n\n      if (p) {\n        const [name, param] = p;\n        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        const value: any = param.parse(val);\n\n        if (value !== undefined && param.validate(val) !== false) {\n          transform[name as keyof Transform] = value;\n          keys.delete(key);\n          return false;\n        }\n      }\n\n      return true;\n    });\n\n    if (Object.keys(transform).length === 0) {\n      sourceFragments.push(fragment);\n\n      if (!stopParsing && transforms.length > 0) {\n        stopParsing = true;\n      }\n    } else {\n      paramsFragments.push(fragment);\n      transforms.push(transform);\n    }\n  });\n\n  const source = sourceFragments.join(\"/\");\n  const ext = extname(source);\n  const target =\n    transforms.length > 0\n      ? source.substring(0, source.length - ext.length) +\n        \"__\" +\n        paramsFragments.join(\"__\") +\n        ext\n      : undefined;\n\n  return {\n    source: source.startsWith(\"/\") ? source.substring(1) : source,\n    target: target?.startsWith(\"/\") ? target.substring(1) : target,\n    transforms,\n  };\n}\n"],"file":"parse.js"}